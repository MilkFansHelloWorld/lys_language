let rec (pow: int -> int -> int) = fun (n:int) -> fun (x:int) -> 
    if n = 0 then 1
    else (x * (pow (n-1) x));;

(* let rec (pow: int -> int -> int) = fun (n:int) -> 
    if n = 0 then (fun (x:int) -> 1) 
    else (fun (x:int) -> x * (pow (n-1) x));;

let rec (pow: int -> int -> int) = fun (n:int) -> 
    if n = 0 then (fun (x:int) -> 1) 
    else
        let pow_n_1:(int -> int) = pow (n-1) in 
        (fun (x:int) -> x * pow_n_1 x);; *)

pow 2 3;; (*gives 9*)

let rec (pow2: int -> [x:int]int) = fun (n:int) -> 
if n = 0 then box (x:int |- 1)
else 
    let box u = pow2 (n-1) in 
        box (x:int |- 
            x * (u with (x))
        );;
pow2 2;;

let box u = pow2 2 in u with (3);; (*gives 9*)

datatype intlist = Nil | Cons of (int * intlist);;

let rec map_int_int:(intlist -> (int -> int) -> intlist) = 
    fun (xs: intlist) -> fun (f:(int -> int)) -> 
    match xs with
    | Nil -> Nil
    | Cons (x, xs) -> Cons (f x, map_int_int xs f);;

let pow_10_compiled: int -> int = fun (x: int) -> let box u = pow2 10 in u with (x)
in
map_int_int (Cons (1, Cons (2, Nil))) (pow 10);;