(* 
    Inspired from Jones Gomard Sestoft, Partial Evaluationand Automatic Program Generation, Section 3.3.1
*)
(*Leq gives 0 if true else 1*)
datatype expr = Int of int | Var of string | Add of (expr * expr) | Leq of (expr * expr);; 
(*If takes left branch if 0 else takes right branch*)
datatype command = Goto of int | Assign of (string * expr) | If of (expr * int * int) | Return of expr;; 
datatype string_list = Nil_s | Cons_s of (string * string_list);;
datatype command_list = Nil_c | Cons_c of (command * command_list);;
datatype int_list = Nil_i | Cons_i of (int * int_list);;
(*program = string_list * command_list *)
datatype env = Nil_env | Cons_env of ((string * int) * env);; (*Only possible value = int*)

(*We do not handle exceptions here*)
(*TODO: Handle exceptions at some point*)

let rec zip: string_list -> int_list -> env = fun (xs: string_list) -> fun (ys: int_list) ->
    match xs with
    | Nil_s -> 
        (match ys with
        | Nil_i -> (Nil_env))
    | Cons_s (x, xs) ->
        (match ys with 
        | Cons_i (y, ys) -> Cons_env ((x, y), zip xs ys));;

(*For evaluation*)
let rec lookup: env -> string -> int = fun (bindings: env) -> fun (id: string) ->
    match bindings with
    | Cons_env (binding, rest) -> if binding[0] = id then (binding[1]) else lookup rest id;;

(*For assignment*)
let rec update: env -> (string * int) -> env = fun (bindings: env) -> fun (id_val: (string * int)) ->
    match bindings with
    | Nil_env -> Cons_env (id_val, Nil_env)
    | Cons_env (id_val_2, rest) -> if id_val_2[0] = id_val[0] then Cons_env (id_val, rest) else 
        Cons_env (id_val_2, update rest id_val);;

(*For jumps*)
let rec nth: command_list -> int -> command = fun (cs: command_list) -> fun (i: int) ->
    match cs with
    | Cons_c (c, cs) ->
        if i = 1 then c
        else nth cs (i-1);;

let rec eval: expr -> env -> int = fun (e: expr) -> fun (store: env) -> 
    match e with
    | Int (n) -> n
    | Var (x) -> lookup store x
    | Add (e1, e2) -> 
        eval e1 store + eval e2 store
    | Leq (e1, e2) ->
        if (eval e1 store) <= (eval e2 store) then 0 else 1;;

let rec run: int -> command -> env -> command_list -> int = fun (l: int) -> fun (c1: command) -> fun (s: env) -> fun (p: command_list) ->
    match c1 with
    | Goto (n) -> run n (nth p n) s p
    | Assign (x, e) -> 
        let s1: env = update s (x, eval e s) in
        run (l + 1) (nth p (l+1)) s1 p
    | If (e, m, n) ->
        if (eval e s) = 0 then
            run m (nth p m) s p
        else
            run n (nth p n) s p
    | Return (e) ->
        eval e s
;;

let interpret: (string_list * command_list) -> int_list -> int
= fun (program: (string_list * command_list)) -> fun (args: int_list) ->
    let store: env = zip program[0] args in
    match program[1] with
    | Cons_c (c, cs) ->
        run 1 c store program[1];;

(*
    Staged version:
    - interpret: (string_list * command_list) -> [args: intlist]int
    - run: int -> command -> commad_list -> [store: env]int
    - eval: expr -> [store: ev]int
    - The rest: just box them.
*)

(*
    https://en.wikipedia.org/wiki/Flow_chart_language
    (n)

    1: x1 = 1
    2: x2 = 1

    3: if leq(n 2) then 4 else 5
    4: return 1

    5: x1 = x1 + x2

    6: t = x1
    7: x1 = x2
    8: x2 = t

    9: n = -(n 1)

    10: if >(n 2) then 5 else 11

    11: return x2
*)
let p: (string_list * command_list) = (
    Cons_s ("n", Nil_s),
    Cons_c (Assign ("x1", Int 1), 
        Cons_c (Assign ("x2", Int 1), 
            Cons_c (If (Leq (Var ("n"), Int (2)), 4, 5),
                Cons_c (Return (Int 1),
                    Cons_c (Assign ("x1", Add (Var ("x1"), Var ("x2"))),
                        Cons_c (Assign ("t", Var ("x1")),
                            Cons_c (Assign ("x1", Var ("x2")),
                                Cons_c (Assign ("x2", Var ("t")),
                                    Cons_c (Assign ("n", Add (Var ("n"), Int (-1))),
                                        Cons_c (If (Leq (Var "n", Int 2), 11, 5),
                                            Cons_c (Return (Var "x2"),
                                                Nil_c
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);;

let a: int_list = Cons_i (10, Nil_i);;

interpret p a;;
