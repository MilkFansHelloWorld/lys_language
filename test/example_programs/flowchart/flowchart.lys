(* 
    Inspired from Jones Gomard Sestoft, Partial Evaluationand Automatic Program Generation, Section 3.3.1
*)

datatype expr = Int of int | Var of string | Add of (expr * expr);;
datatype command = Goto of int | Assign of (string * expr) | If of (expr * int * int) | Return of expr;;
datatype string_list = Nil_s | Cons_s of (string * string_list);;
datatype command_list = Nil_c | Cons_c of (command * command_list);;
datatype int_list = Nil_i | Cons_i of (int * command_list);;
(*program = string_list * command_list *)
datatype env = Nil_env | Cons_env of ((string * int) * env);; (*Only possible value = int*)

(*We do not handle exceptions here*)
(*TODO: Handle exceptions at some point*)

(*For evaluation*)
let rec lookup: env -> string -> int = fun (bindings: env) -> fun (id: string) ->
    match bindings with
    | Cons_env (binding, rest) -> if binding[0] = id then (binding[1]) else lookup rest id;;

(*For assignment*)
let rec update: env -> (string * int) -> env = fun (bindings: env) -> fun (id_val: (string * int)) ->
    match bindings with
    | Nil_env -> Cons_env (id_val, Nil_env)
    | Cons_env (id_val_2, rest) -> if id_val_2[0] = id_val[0] then Cons_env (id_val, rest) else 
        Cons_env (id_val_2, update rest id_val);;

(*For jumps*)
let rec nth: command_list -> int -> command = fun (cs: command_list) -> fun (i: int) ->
    match cs with
    | Cons_c (c, cs) ->
        if i = 1 then c
        else nth cs (i-1);;

let rec eval: expr -> env -> int = fun (e: expr) -> fun (store: env) -> 
    match e with
    | Int (n) -> n
    | Var (x) -> lookup store x
    | Add (e1, e2) -> 
        eval e1 store + eval e2 store;;

let rec run: int -> command -> env -> command_list -> int = fun (l: int) -> fun (c1: command) -> fun (s: env) -> fun (p: command_list) ->
    match c1 with
    | Goto (n) -> run n (nth p n) s p
    | Assign (x, e) -> 
        let s1: env = update s (x, eval e s) in
        run (l + 1) (nth p (l+1)) s1 p
    | If (e, m, n) ->
        if (eval e s) = 0 then
            run m (nth p m) s p
        else
            run n (nth p n) s p
    | Return (e) ->
        eval e s
;;

let interpret: (string_list * command_list) -> int_list -> int
= fun (program: (string_list * command_list)) -> fun (args: int_list) ->
    
