(* 
    Inspired from Jones Gomard Sestoft, Partial Evaluationand Automatic Program Generation, Section 3.3.1
*)

datatype lambda = 
    Int of int | Var of string | Abs of (string * lambda) | Apply of (lambda * lambda) 
    | BinOp of (string * lambda * lambda) | If of (lambda * lambda * lambda)

and value = Numb of int | Closure of (string * lambda * env)

and env = Nil_env | Cons_env of ((string * value) * env)

and lambda_list = Nil_lambda | Cons_lambda of (lambda * lambda_list);;

datatype value_option = None | Some of value;;

let rec lookup: env -> string -> value_option = fun (bindings: env) -> fun (id: string) ->
    match bindings with
    | Nil_env -> None
    | Cons_env (binding, rest) -> if binding[0] = id then Some (binding[1]) else lookup rest id;;

let rec eval: lambda -> env -> value_option = fun (e: lambda) -> fun (bindings: env) -> 
    match e with
    | Int (n) -> Some (Numb n)
    | Var (x) -> lookup bindings x
    | Abs (x, e) -> Some (Closure (x, e, bindings))
    | Apply (e, f) -> 
        let f1_opt: value_option = eval f bindings in
        (match f1_opt with
        | None -> None
        | Some (f1) ->
            let e_eval: value_option = eval e bindings in
            match e_eval with
            | None -> None
            | Some (e_val) ->
                (match e_val with
                | Closure (x, e, clo_bindings) ->
                    eval e (Cons_env ((x, f1), clo_bindings))
                | _ -> None))
    | BinOp (op, e1, e2) ->
        let v1_opt: value_option = eval e1 bindings in
        let v2_opt: value_option = eval e2 bindings in
        (match v1_opt with
        | None -> None
        | Some (v1) ->
            (match v2_opt with
            | None -> None
            | Some (v2) ->
                (* Check both are numbers *)
                match v1 with
                | Numb (n1) ->
                    (match v2 with
                    | Numb (n2) -> Some (Numb (n1 + n2))
                    | _ -> None)
                | _ -> None))
    | If (e, f, g) ->
        match (eval e bindings) with
        | None -> None
        | Some (v_e) ->
            match v_e with
            | Numb (n) ->
                if n = 1 then (eval f bindings)
                else (eval g bindings)
            | _ -> None;;

(* Now staged version *)

let lookup_box: [](env -> string -> value_option) =
    box (|- 
        let rec lookup: env -> string -> value_option = fun (bindings: env) -> fun (id: string) ->
            match bindings with
            | Nil_env -> None
            | Cons_env (binding, rest) -> if binding[0] = id then Some (binding[1]) else lookup rest id
        in
        lookup
    );;

let eval_box: [](lambda -> env -> value_option) = 
let box lookup = lookup_box in
    box (|- 
        let rec eval: lambda -> env -> value_option = fun (e: lambda) -> fun (bindings: env) -> 
            match e with
            | Int (n) -> Some (Numb n)
            | Var (x) -> (lookup with ()) bindings x
            | Abs (x, e) -> Some (Closure (x, e, bindings))
            | Apply (e, f) -> 
                let f1_opt: value_option = eval f bindings in
                (match f1_opt with
                | None -> None
                | Some (f1) ->
                    let e_eval: value_option = eval e bindings in
                    match e_eval with
                    | None -> None
                    | Some (e_val) ->
                        (match e_val with
                        | Closure (x, e, clo_bindings) ->
                            eval e (Cons_env ((x, f1), clo_bindings))
                        | _ -> None))
            | BinOp (op, e1, e2) ->
                let v1_opt: value_option = eval e1 bindings in
                let v2_opt: value_option = eval e2 bindings in
                (match v1_opt with
                | None -> None
                | Some (v1) ->
                    (match v2_opt with
                    | None -> None
                    | Some (v2) ->
                        (* Check both are numbers *)
                        match v1 with
                        | Numb (n1) ->
                            (match v2 with
                            | Numb (n2) -> Some (Numb (n1 + n2))
                            | _ -> None)
                        | _ -> None))
            | If (e, f, g) ->
                match (eval e bindings) with
                | None -> None
                | Some (v_e) ->
                    match v_e with
                    | Numb (n) ->
                        if n = 1 then (eval f bindings)
                        else (eval g bindings)
                    | _ -> None
        in eval
    );;


(* peval accumulates an environment -- Decision is that I'll evaluate anything that does NOT depend on static stuff. 

TODO: Create a pexpr and check if a function can be evaluated at compile time...
If yes we can just evaluate it at compile time. If no we only stall when we don't know what exactly we're gonna execute, in which case need to pass in an application.
*)

datatype pval = Error | Known of value | Unknown of ([bindings: env]value_option);; (*Bindings here mean RUNTIME bindings, not including the compile time ones.*)
datatype string_list = Nil_s | Cons_s of (string * string_list);;

let rec string_list_contains: string_list -> string -> bool = fun (xs: string_list) -> fun (x: string) ->
    match xs with
    | Nil_s -> false
    | Cons (y, ys) -> if x = y then true else (string_list_contains ys x);; 

(*Checks that the expression contains variables which do not depend on any external inputs*)
let rec pcheck_expr_is_known: lambda -> string_list -> bool = fun (e: lambda) -> fun (bound_variables: string_list) ->
    match e with
    | Int (n) -> true
    | Var (x) -> string_list_contains bound_variables x
    | Abs (x, e) -> 
        pcheck_expr_is_known e (Cons (x, bound_variables))
    | Apply (f, e) -> 
        (pcheck_expr_is_known f bound_variables) && (pcheck_expr_is_known e bound_variables)
    | Binop (op, e1, e2) ->
        (pcheck_expr_is_known e1 bound_variables) && (pcheck_expr_is_known e2 bound_variables)
    | If (e, f, g) -> 
        (pcheck_expr_is_known e bound_variables) 
        && (pcheck_expr_is_known f bound_variables)
        && (pcheck_expr_is_known g bound_variables)
;;

(*Environment to variable name list = unzip |> fst *)
let rec env_to_string_list: env -> string_list = fun (xs: env) ->
    match xs with
    | Nil_env -> Nil_s
    | Cons_env (x, xs) -> Cons_s (x[0], env_to_string_list xs);;

let rec concat_staged: env -> [ys: env]env = fun (xs: env) -> 
    match xs with
    | Nil_env -> box (ys: env |- ys)
    | Cons_env (x, xs) -> 
        let box lifted_x = lift[string * value] x in
        let box concat_xs = concat_staged xs in
        box (ys: env |- Cons_env (lifted_x with (), concat_xs with (ys)));;

let rec peval: lambda -> env -> pval = 
    let box lookup_unboxed = lookup_box in
    let box eval_unboxed = eval_box in
    fun (e: lambda) -> fun (known_env: env) -> 
        match e with
        | Int (n) -> Known (Numb (n))
        | Var (x) -> (
            match (lookup known_env x) with
            | None_env -> 
                let box lifted_x = lift[string] x in
                Unknown (box (bindings: env |- (lookup_unboxed with ()) bindings (lifted_x with ())))
            | Some (v) -> 
                Known (v)
        )
        | Abs (x, e) -> 
            let known_variables: string_list = env_to_string_list known_env in
            let pcheck_result: bool = pcheck_expr_is_known e known_variables in
            if pcheck_result then
                Known (Closure (x, e, known_env))
            else
                let box lifted_x = lift[string] x in
                let box lifted_e = lift[lambda] e in
                let box concat_known_env_ = concat_staged known_env in
                Unknown (
                    box (bindings: env |- 
                        Some (
                            Closure (lifted_x with (), lifted e with (), concat_known_env_ with (bindings))
                        )
                    )
                )
        | Apply (e, f) -> 
            let left: pval = peval e known_env in
            let right: pval = peval f known_env in
            (
                match left with
                | Unknown boxed_v_1 -> 
                let box unboxed_v_1 = boxed_v_1 in
                (
                    match right with
                    | Unknown boxed_v_2 ->
                        let box unboxed_v_2 = boxed_v_2 in
                        Unknown (box (bindings: env |- 
                            match (unboxed_v_1 with (bindings)) with
                            | None -> None
                            | Some v1 ->
                                match (unboxed_v_2 with (bindings)) with
                                | None_value -> None
                                | Some_value v2 -> 
                                    match v1 with
                                    | Closure (x, e, clo_bindings) ->
                                        (eval_unboxed with ()) e (Cons_env ((x, v2), clo_bindings))
                                    | _ -> None
                        ))
                    | Known v2 ->
                        let box lifted_v2 = lift[value] v2 in
                        Unknown (box (bindings: env |- 
                            match (unboxed_v_1 with (bindings)) with
                            | None -> None
                            | Some v1 ->
                                match v1 with
                                | Closure (x, e, clo_bindings) ->
                                    (eval_unboxed with ()) e (Cons_env ((x, lifted_v2 with ()), clo_bindings))
                                | _ -> None
                        ))
                    | Error -> Error
                )
                | Known v1 ->
                    (match v1 with 
                    | Closure (x, e, clo_bindings) ->
                        (
                            match right with
                            | Unknown boxed_v_2 -> 
                                let box lifted_x = lift[string] x in
                                let box lifted_e = lift[lambda] e in
                                let box lifted_clo_bindings = lift[env] clo_bindings in
                                let box unboxed_v_2 = boxed_v_2 in
                                Unknown ( box (bindings: env |- 
                                    match (unboxed_v_2 with (bindings)) with
                                    | None -> None
                                    | Some v2 ->
                                        (eval_unboxed with ()) 
                                            (lifted_e with ()) 
                                            (Cons_env ((lifted_x with (), v2), lifted_clo_bindings with ())) 
                                ))
                            | Known v2 ->
                                let new_known_env: env = Cons ((x, v2), clo_bindings) in 
                                peval e new_known_env
                            | Error -> Error
                        )
                    | _ -> Error )
                | Error -> Error
            )
        | BinOp (op, e1, e2) ->
        | If (e, f, g) ->

let expr: lambda = (
    Apply (
        Apply (
            Abs ("x", Abs ("y", BinOp ("+", Var ("x"), Var ("y")))),
            Int (1)
        ),
        Int (2)
    )
);;

eval expr (Nil_env);;
